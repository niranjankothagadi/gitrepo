/* File automatically generated by Parser/asdl_c.py. */

#include <stddef.h>

#include "Python.h"
#include "Python-ast.h"

static PyTypeObject AST_type;
static PyTypeObject *mod_type;
static PyObject* ast2obj_mod(void*);
static PyTypeObject *Module_type;
_Py_IDENTIFIER(body);
_Py_IDENTIFIER(docstring);
static char *Module_fields[]={
    "body",
    "docstring",
};
static PyTypeObject *Interactive_type;
static char *Interactive_fields[]={
    "body",
};
static PyTypeObject *Expression_type;
static char *Expression_fields[]={
    "body",
};
static PyTypeObject *Suite_type;
static char *Suite_fields[]={
    "body",
};
static PyTypeObject *stmt_type;
_Py_IDENTIFIER(lineno);
_Py_IDENTIFIER(col_offset);
static char *stmt_attributes[] = {
    "lineno",
    "col_offset",
};
static PyObject* ast2obj_stmt(void*);
static PyTypeObject *FunctionDef_type;
_Py_IDENTIFIER(name);
_Py_IDENTIFIER(args);
_Py_IDENTIFIER(decorator_list);
_Py_IDENTIFIER(returns);
static char *FunctionDef_fields[]={
    "name",
    "args",
    "body",
    "decorator_list",
    "returns",
    "docstring",
};
static PyTypeObject *AsyncFunctionDef_type;
static char *AsyncFunctionDef_fields[]={
    "name",
    "args",
    "body",
    "decorator_list",
    "returns",
    "docstring",
};
static PyTypeObject *ClassDef_type;
_Py_IDENTIFIER(bases);
_Py_IDENTIFIER(keywords);
static char *ClassDef_fields[]={
    "name",
    "bases",
    "keywords",
    "body",
    "decorator_list",
    "docstring",
};
static PyTypeObject *Return_type;
_Py_IDENTIFIER(value);
static char *Return_fields[]={
    "value",
};
static PyTypeObject *Delete_type;
_Py_IDENTIFIER(targets);
static char *Delete_fields[]={
    "targets",
};
static PyTypeObject *Assign_type;
static char *Assign_fields[]={
    "targets",
    "value",
};
static PyTypeObject *AugAssign_type;
_Py_IDENTIFIER(target);
_Py_IDENTIFIER(op);
static char *AugAssign_fields[]={
    "target",
    "op",
    "value",
};
static PyTypeObject *AnnAssign_type;
_Py_IDENTIFIER(annotation);
_Py_IDENTIFIER(simple);
static char *AnnAssign_fields[]={
    "target",
    "annotation",
    "value",
    "simple",
};
static PyTypeObject *For_type;
_Py_IDENTIFIER(iter);
_Py_IDENTIFIER(orelse);
static char *For_fields[]={
    "target",
    "iter",
    "body",
    "orelse",
};
static PyTypeObject *AsyncFor_type;
static char *AsyncFor_fields[]={
    "target",
    "iter",
    "body",
    "orelse",
};
static PyTypeObject *While_type;
_Py_IDENTIFIER(test);
static char *While_fields[]={
    "test",
    "body",
    "orelse",
};
static PyTypeObject *If_type;
static char *If_fields[]={
    "test",
    "body",
    "orelse",
};
static PyTypeObject *With_type;
_Py_IDENTIFIER(items);
static char *With_fields[]={
    "items",
    "body",
};
static PyTypeObject *AsyncWith_type;
static char *AsyncWith_fields[]={
    "items",
    "body",
};
static PyTypeObject *Raise_type;
_Py_IDENTIFIER(exc);
_Py_IDENTIFIER(cause);
static char *Raise_fields[]={
    "exc",
    "cause",
};
static PyTypeObject *Try_type;
_Py_IDENTIFIER(handlers);
_Py_IDENTIFIER(finalbody);
static char *Try_fields[]={
    "body",
    "handlers",
    "orelse",
    "finalbody",
};
static PyTypeObject *Assert_type;
_Py_IDENTIFIER(msg);
static char *Assert_fields[]={
    "test",
    "msg",
};
static PyTypeObject *Import_type;
_Py_IDENTIFIER(names);
static char *Import_fields[]={
    "names",
};
static PyTypeObject *ImportFrom_type;
_Py_IDENTIFIER(module);
_Py_IDENTIFIER(level);
static char *ImportFrom_fields[]={
    "module",
    "names",
    "level",
};
static PyTypeObject *Global_type;
static char *Global_fields[]={
    "names",
};
static PyTypeObject *Nonlocal_type;
static char *Nonlocal_fields[]={
    "names",
};
static PyTypeObject *Expr_type;
static char *Expr_fields[]={
    "value",
};
static PyTypeObject *Pass_type;
static PyTypeObject *Break_type;
static PyTypeObject *Continue_type;
static PyTypeObject *expr_type;
static char *expr_attributes[] = {
    "lineno",
    "col_offset",
};
static PyObject* ast2obj_expr(void*);
static PyTypeObject *BoolOp_type;
_Py_IDENTIFIER(values);
static char *BoolOp_fields[]={
    "op",
    "values",
};
static PyTypeObject *BinOp_type;
_Py_IDENTIFIER(left);
_Py_IDENTIFIER(right);
static char *BinOp_fields[]={
    "left",
    "op",
    "right",
};
static PyTypeObject *UnaryOp_type;
_Py_IDENTIFIER(operand);
static char *UnaryOp_fields[]={
    "op",
    "operand",
};
static PyTypeObject *Lambda_type;
static char *Lambda_fields[]={
    "args",
    "body",
};
static PyTypeObject *IfExp_type;
static char *IfExp_fields[]={
    "test",
    "body",
    "orelse",
};
static PyTypeObject *Dict_type;
_Py_IDENTIFIER(keys);
static char *Dict_fields[]={
    "keys",
    "values",
};
static PyTypeObject *Set_type;
_Py_IDENTIFIER(elts);
static char *Set_fields[]={
    "elts",
};
static PyTypeObject *ListComp_type;
_Py_IDENTIFIER(elt);
_Py_IDENTIFIER(generators);
static char *ListComp_fields[]={
    "elt",
    "generators",
};
static PyTypeObject *SetComp_type;
static char *SetComp_fields[]={
    "elt",
    "generators",
};
static PyTypeObject *DictComp_type;
_Py_IDENTIFIER(key);
static char *DictComp_fields[]={
    "key",
    "value",
    "generators",
};
static PyTypeObject *GeneratorExp_type;
static char *GeneratorExp_fields[]={
    "elt",
    "generators",
};
static PyTypeObject *Await_type;
static char *Await_fields[]={
    "value",
};
static PyTypeObject *Yield_type;
static char *Yield_fields[]={
    "value",
};
static PyTypeObject *YieldFrom_type;
static char *YieldFrom_fields[]={
    "value",
};
static PyTypeObject *Compare_type;
_Py_IDENTIFIER(ops);
_Py_IDENTIFIER(comparators);
static char *Compare_fields[]={
    "left",
    "ops",
    "comparators",
};
static PyTypeObject *Call_type;
_Py_IDENTIFIER(func);
static char *Call_fields[]={
    "func",
    "args",
    "keywords",
};
static PyTypeObject *Num_type;
_Py_IDENTIFIER(n);
static char *Num_fields[]={
    "n",
};
static PyTypeObject *Str_type;
_Py_IDENTIFIER(s);
static char *Str_fields[]={
    "s",
};
static PyTypeObject *FormattedValue_type;
_Py_IDENTIFIER(conversion);
_Py_IDENTIFIER(format_spec);
static char *FormattedValue_fields[]={
    "value",
    "conversion",
    "format_spec",
};
static PyTypeObject *JoinedStr_type;
static char *JoinedStr_fields[]={
    "values",
};
static PyTypeObject *Bytes_type;
static char *Bytes_fields[]={
    "s",
};
static PyTypeObject *NameConstant_type;
static char *NameConstant_fields[]={
    "value",
};
static PyTypeObject *Ellipsis_type;
static PyTypeObject *Constant_type;
static char *Constant_fields[]={
    "value",
};
static PyTypeObject *Attribute_type;
_Py_IDENTIFIER(attr);
_Py_IDENTIFIER(ctx);
static char *Attribute_fields[]={
    "value",
    "attr",
    "ctx",
};
static PyTypeObject *Subscript_type;
_Py_IDENTIFIER(slice);
static char *Subscript_fields[]={
    "value",
    "slice",
    "ctx",
};
static PyTypeObject *Starred_type;
static char *Starred_fields[]={
    "value",
    "ctx",
};
static PyTypeObject *Name_type;
_Py_IDENTIFIER(id);
static char *Name_fields[]={
    "id",
    "ctx",
};
static PyTypeObject *List_type;
static char *List_fields[]={
    "elts",
    "ctx",
};
static PyTypeObject *Tuple_type;
static char *Tuple_fields[]={
    "elts",
    "ctx",
};
static PyTypeObject *expr_context_type;
static PyObject *Load_singleton, *Store_singleton, *Del_singleton,
*AugLoad_singleton, *AugStore_singleton, *Param_singleton;
static PyObject* ast2obj_expr_context(expr_context_ty);
static PyTypeObject *Load_type;
static PyTypeObject *Store_type;
static PyTypeObject *Del_type;
static PyTypeObject *AugLoad_type;
static PyTypeObject *AugStore_type;
static PyTypeObject *Param_type;
static PyTypeObject *slice_type;
static PyObject* ast2obj_slice(void*);
static PyTypeObject *Slice_type;
_Py_IDENTIFIER(lower);
_Py_IDENTIFIER(upper);
_Py_IDENTIFIER(step);
static char *Slice_fields[]={
    "lower",
    "upper",
    "step",
};
static PyTypeObject *ExtSlice_type;
_Py_IDENTIFIER(dims);
static char *ExtSlice_fields[]={
    "dims",
};
static PyTypeObject *Index_type;
static char *Index_fields[]={
    "value",
};
static PyTypeObject *boolop_type;
static PyObject *And_singleton, *Or_singleton;
static PyObject* ast2obj_boolop(boolop_ty);
static PyTypeObject *And_type;
static PyTypeObject *Or_type;
static PyTypeObject *operator_type;
static PyObject *Add_singleton, *Sub_singleton, *Mult_singleton,
*MatMult_singleton, *Div_singleton, *Mod_singleton, *Pow_singleton,
*LShift_singleton, *RShift_singleton, *BitOr_singleton, *BitXor_singleton,
*BitAnd_singleton, *FloorDiv_singleton;
static PyObject* ast2obj_operator(operator_ty);
static PyTypeObject *Add_type;
static PyTypeObject *Sub_type;
static PyTypeObject *Mult_type;
static PyTypeObject *MatMult_type;
static PyTypeObject *Div_type;
static PyTypeObject *Mod_type;
static PyTypeObject *Pow_type;
static PyTypeObject *LShift_type;
static PyTypeObject *RShift_type;
static PyTypeObject *BitOr_type;
static PyTypeObject *BitXor_type;
static PyTypeObject *BitAnd_type;
static PyTypeObject *FloorDiv_type;
static PyTypeObject *unaryop_type;
static PyObject *Invert_singleton, *Not_singleton, *UAdd_singleton,
*USub_singleton;
static PyObject* ast2obj_unaryop(unaryop_ty);
static PyTypeObject *Invert_type;
static PyTypeObject *Not_type;
static PyTypeObject *UAdd_type;
static PyTypeObject *USub_type;
static PyTypeObject *cmpop_type;
static PyObject *Eq_singleton, *NotEq_singleton, *Lt_singleton, *LtE_singleton,
*Gt_singleton, *GtE_singleton, *Is_singleton, *IsNot_singleton, *In_singleton,
*NotIn_singleton;
static PyObject* ast2obj_cmpop(cmpop_ty);
static PyTypeObject *Eq_type;
static PyTypeObject *NotEq_type;
static PyTypeObject *Lt_type;
static PyTypeObject *LtE_type;
static PyTypeObject *Gt_type;
static PyTypeObject *GtE_type;
static PyTypeObject *Is_type;
static PyTypeObject *IsNot_type;
static PyTypeObject *In_type;
static PyTypeObject *NotIn_type;
static PyTypeObject *comprehension_type;
static PyObject* ast2obj_comprehension(void*);
_Py_IDENTIFIER(ifs);
_Py_IDENTIFIER(is_async);
static char *comprehension_fields[]={
    "target",
    "iter",
    "ifs",
    "is_async",
};
static PyTypeObject *excepthandler_type;
static char *excepthandler_attributes[] = {
    "lineno",
    "col_offset",
};
static PyObject* ast2obj_excepthandler(void*);
static PyTypeObject *ExceptHandler_type;
_Py_IDENTIFIER(type);
static char *ExceptHandler_fields[]={
    "type",
    "name",
    "body",
};
static PyTypeObject *arguments_type;
static PyObject* ast2obj_arguments(void*);
_Py_IDENTIFIER(vararg);
_Py_IDENTIFIER(kwonlyargs);
_Py_IDENTIFIER(kw_defaults);
_Py_IDENTIFIER(kwarg);
_Py_IDENTIFIER(defaults);
static char *arguments_fields[]={
    "args",
    "vararg",
    "kwonlyargs",
    "kw_defaults",
    "kwarg",
    "defaults",
};
static PyTypeObject *arg_type;
static PyObject* ast2obj_arg(void*);
static char *arg_attributes[] = {
    "lineno",
    "col_offset",
};
_Py_IDENTIFIER(arg);
static char *arg_fields[]={
    "arg",
    "annotation",
};
static PyTypeObject *keyword_type;
static PyObject* ast2obj_keyword(void*);
static char *keyword_fields[]={
    "arg",
    "value",
};
static PyTypeObject *alias_type;
static PyObject* ast2obj_alias(void*);
_Py_IDENTIFIER(asname);
static char *alias_fields[]={
    "name",
    "asname",
};
static PyTypeObject *withitem_type;
static PyObject* ast2obj_withitem(void*);
_Py_IDENTIFIER(context_expr);
_Py_IDENTIFIER(optional_vars);
static char *withitem_fields[]={
    "context_expr",
    "optional_vars",
};


_Py_IDENTIFIER(_fields);
_Py_IDENTIFIER(_attributes);

typedef struct {
    PyObject_HEAD
    PyObject *dict;
} AST_object;

static void
ast_dealloc(AST_object *self)
{
    Py_CLEAR(self->dict);
    Py_TYPE(self)->tp_free(self);
}

static int
ast_traverse(AST_object *self, visitproc visit, void *arg)
{
    Py_VISIT(self->dict);
    return 0;
}

static void
ast_clear(AST_object *self)
{
    Py_CLEAR(self->dict);
}

static int
ast_type_init(PyObject *self, PyObject *args, PyObject *kw)
{
    Py_ssize_t i, numfields = 0;
    int res = -1;
    PyObject *key, *value, *fields;
    fields = _PyObject_GetAttrId((PyObject*)Py_TYPE(self), &PyId__fields);
    if (!fields)
        PyErr_Clear();
    if (fields) {
        numfields = PySequence_Size(fields);
        if (numfields == -1)
            goto cleanup;
    }

    res = 0; /* if no error occurs, this stays 0 to the end */
    if (numfields < PyTuple_GET_SIZE(args)) {
        PyErr_Format(PyExc_TypeError, "%.400s constructor takes at most "
                     "%zd positional argument%s",
                     Py_TYPE(self)->tp_name,
                     numfields, numfields == 1 ? "" : "s");
        res = -1;
        goto cleanup;
    }
    for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
        /* cannot be reached when fields is NULL */
        PyObject *name = PySequence_GetItem(fields, i);
        if (!name) {
            res = -1;
            goto cleanup;
        }
        res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));
        Py_DECREF(name);
        if (res < 0)
            goto cleanup;
    }
    if (kw) {
        i = 0;  /* needed by PyDict_Next */
        while (PyDict_Next(kw, &i, &key, &value)) {
            res = PyObject_SetAttr(self, key, value);
            if (res < 0)
                goto cleanup;
        }
    }
  cleanup:
    Py_XDECREF(fields);
    return res;
}

/* Pickling support */
static PyObject *
ast_type_reduce(PyObject *self, PyObject *unused)
{
    PyObject *res;
    _Py_IDENTIFIER(__dict__);
    PyObject *dict = _PyObject_GetAttrId(self, &PyId___dict__);
    if (dict == NULL) {
        if (PyErr_ExceptionMatches(PyExc_AttributeError))
            PyErr_Clear();
        else
            return NULL;
    }
    if (dict) {
        res = Py_BuildValue("O()O", Py_TYPE(self), dict);
        Py_DECREF(dict);
        return res;
    }
    return Py_BuildValue("O()", Py_TYPE(self));
}

static PyMethodDef ast_type_methods[] = {
    {"__reduce__", ast_type_reduce, METH_NOARGS, NULL},
    {NULL}
};

static PyGetSetDef ast_type_getsets[] = {
    {"__dict__", PyObject_GenericGetDict, PyObject_GenericSetDict},
    {NULL}
};